<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate Snake Game - Jungle Edition</title>
    <style>
        /* CSS VARIABLES FOR THEMING */
        :root {
            --bg-body: #202028;
            --bg-canvas: #000000;
            --snake-color: #00FF00;
            --text-color: #ffffff;
            --accent-color: #444444;
            --font-family: 'Courier New', Courier, monospace;
        }

        /* GLOBAL STYLES */
        body {
            background-color: var(--bg-body);
            color: var(--text-color);
            font-family: var(--font-family);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            transition: background-color 0.3s;
        }

        h1 {
            margin: 0 0 10px 0;
            text-shadow: 2px 2px var(--snake-color);
        }

        /* GAME UI LAYOUT */
        .game-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .stats-bar {
            display: flex;
            justify-content: space-between;
            width: 400px;
            font-size: 1.2rem;
            font-weight: bold;
        }

        canvas {
            background-color: var(--bg-canvas);
            border: 4px solid var(--snake-color);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            display: block;
            border-radius: 4px;
        }

        /* CONTROLS AREA */
        .controls {
            margin-top: 15px;
            background: var(--accent-color);
            padding: 15px;
            border-radius: 8px;
            display: flex;
            gap: 15px;
            align-items: center;
        }

        select, button {
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            font-family: var(--font-family);
            font-weight: bold;
            cursor: pointer;
        }

        button {
            background-color: var(--snake-color);
            color: var(--bg-canvas);
            font-size: 1rem;
            transition: transform 0.1s;
        }

        button:active {
            transform: scale(0.95);
        }

        button:hover {
            opacity: 0.9;
        }

        /* OVERLAY FOR GAME OVER */
        #message {
            position: absolute;
            color: white;
            font-size: 2rem;
            font-weight: bold;
            text-align: center;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            display: none; /* Hidden by default */
            pointer-events: none;
            backdrop-filter: blur(2px);
        }
    </style>
</head>
<body>

    <div class="game-wrapper">
        <h1>SNAKE</h1>
        
        <div class="stats-bar">
            <span>Score: <span id="score">0</span></span>
            <span>High Score: <span id="highScore">0</span></span>
        </div>

        <div style="position: relative;">
            <canvas id="gameCanvas" width="400" height="400"></canvas>
            <div id="message">GAME OVER<br><span style="font-size: 1rem">Press Space to Restart</span></div>
        </div>

        <div class="controls">
            <div>
                <label for="speedSelect">Speed:</label>
                <select id="speedSelect">
                    <option value="150">Easy</option>
                    <option value="100" selected>Normal</option>
                    <option value="60">Hard</option>
                    <option value="40">Insane</option>
                </select>
            </div>
            
            <div>
                <label for="themeSelect">Theme:</label>
                <select id="themeSelect">
                    <option value="classic">Classic</option>
                    <option value="retro">Retro GB</option>
                    <option value="cyber">Cyberpunk</option>
                    <option value="pastel">Pastel</option>
                    <option value="jungle">Jungle</option>
                </select>
            </div>

            <button onclick="resetGame()">Restart</button>
        </div>
        <p style="font-size: 0.8rem; opacity: 0.7;">Use Arrow Keys or WASD to move</p>
    </div>

    <script>
        // --- CONFIGURATION & STATE ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const highScoreEl = document.getElementById('highScore');
        const messageEl = document.getElementById('message');
        const speedSelect = document.getElementById('speedSelect');
        const themeSelect = document.getElementById('themeSelect');

        const gridSize = 20; // Size of one square
        const tileCount = canvas.width / gridSize;

        // Fruit Options
        const fruits = ["üçé", "üçê", "üçä", "üçá", "üçâ", "üçí", "üçì", "üçç"];

        let score = 0;
        let highScore = localStorage.getItem('snakeHighScore') || 0;
        highScoreEl.innerText = highScore;

        let velocityX = 0;
        let velocityY = 0;
        let snake = [];
        let food = { x: 10, y: 10, type: "üçé" };
        let gameInterval;
        let isGameRunning = false;
        let gameSpeed = 100;

        // --- THEMES ---
        const themes = {
            classic: {
                '--bg-body': '#202028',
                '--bg-canvas': '#000000',
                '--snake-color': '#00FF00',
                '--text-color': '#ffffff',
                '--accent-color': '#444444'
            },
            retro: {
                '--bg-body': '#8b9c0f',
                '--bg-canvas': '#9bbc0f',
                '--snake-color': '#0f380f',
                '--text-color': '#0f380f',
                '--accent-color': '#8b9c0f'
            },
            cyber: {
                '--bg-body': '#0b0c15',
                '--bg-canvas': '#111',
                '--snake-color': '#0ff',
                '--text-color': '#0ff',
                '--accent-color': '#222'
            },
            pastel: {
                '--bg-body': '#FFF5E1',
                '--bg-canvas': '#FFFFFF',
                '--snake-color': '#FF9AA2',
                '--text-color': '#666',
                '--accent-color': '#FFDAC1'
            },
            jungle: {
                '--bg-body': '#0D1F12',
                '--bg-canvas': '#1E4D2B',
                '--snake-color': '#ADFF2F', /* GreenYellow */
                '--text-color': '#E8F5E9',
                '--accent-color': '#2E7D32'
            }
        };

        // --- INITIALIZATION ---
        function init() {
            snake = [{ x: 10, y: 10 }, { x: 9, y: 10 }, { x: 8, y: 10 }]; // Start with small body
            velocityX = 0;
            velocityY = 0; // Stationary at start
            score = 0;
            scoreEl.innerText = score;
            messageEl.style.display = 'none';
            isGameRunning = true;
            placeFood();
            
            gameSpeed = parseInt(speedSelect.value);
            
            if (gameInterval) clearInterval(gameInterval);
            gameInterval = setInterval(gameLoop, gameSpeed);
        }

        // --- GAME LOOP ---
        function gameLoop() {
            update();
            draw();
        }

        // --- UPDATE LOGIC ---
        function update() {
            const head = { x: snake[0].x + velocityX, y: snake[0].y + velocityY };

            // 1. Check Wall Collision
            if (head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount) {
                gameOver();
                return;
            }

            // 2. Check Self Collision (Only if moving)
            if (velocityX !== 0 || velocityY !== 0) {
                for (let i = 0; i < snake.length; i++) {
                    if (head.x === snake[i].x && head.y === snake[i].y) {
                        gameOver();
                        return;
                    }
                }
            }

            // Only move snake array if we have velocity (game started)
            if (velocityX !== 0 || velocityY !== 0) {
                snake.unshift(head);

                // 3. Check Food Collision
                if (head.x === food.x && head.y === food.y) {
                    score += 10;
                    scoreEl.innerText = score;
                    placeFood();
                    // Don't pop tail = grow
                } else {
                    snake.pop(); // Maintain length
                }
            }
        }

        // --- DRAWING ---
        function draw() {
            // Clear Canvas
            const bgCanvas = getComputedStyle(document.body).getPropertyValue('--bg-canvas');
            const snakeColor = getComputedStyle(document.body).getPropertyValue('--snake-color');

            ctx.fillStyle = bgCanvas;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw Food (Fruit Emoji)
            ctx.font = `${gridSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // Add a subtle glow behind fruit
            ctx.shadowBlur = 15;
            ctx.shadowColor = "rgba(255, 255, 255, 0.5)";
            
            const fruitX = food.x * gridSize + gridSize / 2;
            const fruitY = food.y * gridSize + gridSize / 2 + 2; 
            ctx.fillText(food.type, fruitX, fruitY);
            
            ctx.shadowBlur = 0; // Reset shadow

            // Draw Snake
            ctx.fillStyle = snakeColor;
            
            snake.forEach((part, index) => {
                const x = part.x * gridSize;
                const y = part.y * gridSize;
                
                // Draw Body Part (Rounded Rectangle)
                drawRoundedRect(ctx, x, y, gridSize, gridSize, 6);

                // Draw Head Eyes
                if (index === 0) {
                    drawHeadFeatures(x, y);
                }
            });
        }

        function drawRoundedRect(ctx, x, y, width, height, radius) {
            ctx.beginPath();
            ctx.roundRect(x + 1, y + 1, width - 2, height - 2, radius);
            ctx.fill();
        }

        function drawHeadFeatures(x, y) {
            ctx.fillStyle = "white"; // Eye whites
            
            // Determine Eye Offsets based on Velocity
            let eyeOffsetX = 0;
            let eyeOffsetY = 0;
            
            if (velocityX === 1 || (velocityX === 0 && velocityY === 0)) { eyeOffsetX = 4; } // Right
            if (velocityX === -1) { eyeOffsetX = -4; } // Left
            if (velocityY === 1) { eyeOffsetY = 4; } // Down
            if (velocityY === -1) { eyeOffsetY = -4; } // Up

            // Left Eye
            ctx.beginPath();
            ctx.arc(x + gridSize/2 - 4 + eyeOffsetX/2, y + gridSize/2 - 4 + eyeOffsetY/2, 3, 0, Math.PI * 2);
            ctx.fill();

            // Right Eye
            ctx.beginPath();
            ctx.arc(x + gridSize/2 + 4 + eyeOffsetX/2, y + gridSize/2 - 4 + eyeOffsetY/2, 3, 0, Math.PI * 2);
            
            // Adjust for vertical looking
            if(velocityY !== 0) {
                 ctx.fillStyle = "white";
                 ctx.beginPath();
                 ctx.arc(x + gridSize/2 - 4, y + gridSize/2 + eyeOffsetY, 3, 0, Math.PI * 2);
                 ctx.fill();
                 ctx.beginPath();
                 ctx.arc(x + gridSize/2 + 4, y + gridSize/2 + eyeOffsetY, 3, 0, Math.PI * 2);
                 ctx.fill();
            } else {
                 ctx.fill();
            }

            // Pupils
            ctx.fillStyle = "black";
            
            if(velocityY !== 0) {
                 ctx.beginPath();
                 ctx.arc(x + gridSize/2 - 4, y + gridSize/2 + eyeOffsetY + (velocityY*1), 1.5, 0, Math.PI * 2);
                 ctx.fill();
                 ctx.beginPath();
                 ctx.arc(x + gridSize/2 + 4, y + gridSize/2 + eyeOffsetY + (velocityY*1), 1.5, 0, Math.PI * 2);
                 ctx.fill();
            } else {
                 ctx.beginPath();
                 ctx.arc(x + gridSize/2 - 4 + (eyeOffsetX > 0 ? 2 : -2), y + gridSize/2 - 4, 1.5, 0, Math.PI * 2);
                 ctx.fill();
                 ctx.beginPath();
                 ctx.arc(x + gridSize/2 + 4 + (eyeOffsetX > 0 ? 2 : -2), y + gridSize/2 - 4, 1.5, 0, Math.PI * 2);
                 ctx.fill();
            }
            
            // Reset to snake color
            const snakeColor = getComputedStyle(document.body).getPropertyValue('--snake-color');
            ctx.fillStyle = snakeColor;
        }

        // --- HELPERS ---
        function placeFood() {
            const randomFruit = fruits[Math.floor(Math.random() * fruits.length)];
            food = {
                x: Math.floor(Math.random() * tileCount),
                y: Math.floor(Math.random() * tileCount),
                type: randomFruit
            };
            for (let part of snake) {
                if (part.x === food.x && part.y === food.y) {
                    placeFood();
                }
            }
        }

        function gameOver() {
            isGameRunning = false;
            clearInterval(gameInterval);
            
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('snakeHighScore', highScore);
                highScoreEl.innerText = highScore;
            }
            messageEl.style.display = 'block';
        }

        function resetGame() {
            init();
        }

        function applyTheme(themeName) {
            const theme = themes[themeName];
            for (const key in theme) {
                document.documentElement.style.setProperty(key, theme[key]);
            }
            draw();
        }

        // --- INPUT HANDLING ---
        document.addEventListener('keydown', keyDownEvent);

        function keyDownEvent(e) {
            if(["Space","ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].indexOf(e.code) > -1) {
                e.preventDefault();
            }

            if (!isGameRunning && e.code === "Space") {
                resetGame();
                return;
            }

            if (velocityX === 0 && velocityY === 0 && isGameRunning) {
                 switch (e.key) {
                    case 'ArrowLeft': case 'a': case 'A': velocityX = -1; velocityY = 0; break;
                    case 'ArrowUp': case 'w': case 'W': velocityX = 0; velocityY = -1; break;
                    case 'ArrowRight': case 'd': case 'D': velocityX = 1; velocityY = 0; break;
                    case 'ArrowDown': case 's': case 'S': velocityX = 0; velocityY = 1; break;
                }
                return;
            }

            switch (e.key) {
                case 'ArrowLeft': case 'a': case 'A':
                    if (velocityX !== 1) { velocityX = -1; velocityY = 0; }
                    break;
                case 'ArrowUp': case 'w': case 'W':
                    if (velocityY !== 1) { velocityX = 0; velocityY = -1; }
                    break;
                case 'ArrowRight': case 'd': case 'D':
                    if (velocityX !== -1) { velocityX = 1; velocityY = 0; }
                    break;
                case 'ArrowDown': case 's': case 'S':
                    if (velocityY !== -1) { velocityX = 0; velocityY = 1; }
                    break;
            }
        }

        themeSelect.addEventListener('change', (e) => {
            applyTheme(e.target.value);
            canvas.focus();
        });

        speedSelect.addEventListener('change', () => {
            if(isGameRunning && (velocityX !== 0 || velocityY !== 0)) {
                clearInterval(gameInterval);
                gameSpeed = parseInt(speedSelect.value);
                gameInterval = setInterval(gameLoop, gameSpeed);
            }
            canvas.focus();
        });

        init();

    </script>
</body>
</html>